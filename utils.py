import os
import time
import shutil
import zipfile
from dotenv import load_dotenv
import google.generativeai as genai

load_dotenv()
genai.configure(api_key=os.environ['GEMINI_API_KEY'])


SAFE = [
        {
            "category": "HARM_CATEGORY_DANGEROUS",
            "threshold": "BLOCK_NONE",
        },
        {
            "category": "HARM_CATEGORY_HARASSMENT",
            "threshold": "BLOCK_NONE",
        },
        {
            "category": "HARM_CATEGORY_HATE_SPEECH",
            "threshold": "BLOCK_NONE",
        },
        {
            "category": "HARM_CATEGORY_SEXUALLY_EXPLICIT",
            "threshold": "BLOCK_NONE",
        },
        {
            "category": "HARM_CATEGORY_DANGEROUS_CONTENT",
            "threshold": "BLOCK_NONE",
        },
    ]    

def generate_new_name_from_text(original_name: str) -> str:
    """Generates a new name for a given file name using Gemini.

    Args:
        original_name (str): The old name of the file.

    Returns:
        str: The new name of the file.
    """
    
    example = """Example 1: Original name: 'pikaso_texttoimage_Big-Parade-Float-With-Thanksgiving-Feasts-And-Perf' -> New name: 'Big Parade Float With Thanksgiving Feasts And Performance'
                 Example 2: Original name: 'pikaso_texttoimage_Big-Parade-Float-With-Thanksgiving-Feasts-And-Perf' -> New name: 'Big Parade Float With Thanksgiving Feasts'
                 Example 3: Original name: 'pikaso_edit_A-Cartoon-Dragon-Playing-The-Piano-In-A-Beautiful-' -> New name: 'A Cartoon Dragon Playing The Piano In A Beautifully'"""
   
    prompt = f""" You are provided with an original name of a file. {original_name} Your task is to generate a new name for the file, using the original name. 
    
    Original Name Explanation:
        1) The name is a description of the file, but it is not formatted correctly
        2) It starts with some kind of label which indicates it was generated by a text to image model. 
        3) The image name is often not complete and ends abrubtly.
    
    Instructions:
        1) Make sure to use the original name to understand what the file is about.
        2) Remove the tag that indicates it was generated by text to image,
        3) Make sure the new name is complete and descriptive. Rephrase it if needed to explain the image better.
        4) It should not have any dashes or underscores or special characters, and should be in title case and have alphabetical characters only.
        5) It should make sense and not sound incomplete. If you cannot complete the last word of the name, then come up with a name without using it.
        6) It should be grammatically correct.
        
    
    Use these examples for reference:
        {example} 
    
    Output:
        Your output should just be the new name. 
    """
    
    max_retries = 3
    retry_count = 0
    
    while retry_count < max_retries:
        try:
            model = genai.GenerativeModel("gemini-1.5-flash")        
            
            response = model.generate_content(
                prompt,
                safety_settings=SAFE
            )
            new_name = response.text.strip()
            return new_name
        except Exception as e:
            retry_count += 1
            print(f"Error generating new name (attempt {retry_count}/{max_retries}): {e}")
            if retry_count < max_retries:
                sleep_time = 2 * retry_count  # Exponential backoff
                print(f"Retrying in {sleep_time} seconds...")
                time.sleep(sleep_time)
            else:
                print("Max retries reached, using fallback name")
                return f"Renamed {original_name.split('_')[-1]}"
    
    return f"Renamed File {int(time.time())}"


def generate_new_name_from_image(file_path: str, file_name: str) -> str:
    """Generates a new name for an image file using Gemini.
    
    Args:
        file_path (str): Path to the image file
        file_name (str): Original name of the file
        
    Returns:
        str: New name for the file
    """
    max_retries = 3
    retry_count = 0
    
    while retry_count < max_retries:
        try:
            myfile = genai.upload_file(file_path)
            topic = "Daisy Duck"
            example = """Example 1: Original name: 'pikaso_texttoimage_Big-Parade-Float-With-Thanksgiving-Feasts-And-Perf' -> New name: 'Big Parade Float With Thanksgiving Feasts'
                         Example 2: Original name: 'pikaso_edit_A-Cartoon-Dragon-Playing-The-Piano-In-A-Beautiful-' -> New name: 'Cartoon Dragon Playing Piano Beautifully'"""
            
            prompt = f"""
            You are provided with an image and its old name. Your task is to generate a new name for the image.
            The image is of a '{topic}' so ensure that every name starts with it.
        
            Old Name: {file_name}
            
            Instructions:
                1) Make sure to look at the image and understand what it is about.
                2) Make sure to look at the old name and understand what the image is about.
                3) The new name should be descriptive and should explain the image well.
                4) It should be in title case.
                5) It should not have any dashes or underscores or special characters, and should be in title case and have alphabetical characters only.
                6) It should be grammatically correct.
                7) It shuold not be the same as the old name.
        
            Use these examples for reference:
                {example} 
        
            Output:
                Your output should just be the new name. Ensure that you do not return the old name as the new name.
            """
            
            model = genai.GenerativeModel("gemini-1.5-flash")
            result = model.generate_content(
                [myfile, "\n\n", prompt],
                safety_settings=SAFE
            )
            
            new_name = result.text
            return new_name
        
        except Exception as e:
            retry_count += 1
            print(f"Error generating name from image (attempt {retry_count}/{max_retries}): {e}")
            if retry_count < max_retries:
                sleep_time = 2 * retry_count  # Exponential backoff
                print(f"Retrying in {sleep_time} seconds...")
                time.sleep(sleep_time)
            else:
                print("Max retries reached, using fallback name")
                return f"Image {int(time.time())}"
    
    return f"Image {int(time.time())}"

def zip_up(renamed_files: list, zip_path: str) -> str:
    """Zips up the selected files into a zip file, handling duplicates.

    Args:
        renamed_files (list): The list of file locations that need to be zipped up.
        zip_path (str): The path where the zip file should be saved. It is a directory path.

    Returns:
        str: The path of the zip file.
    """
    
    if not os.path.isdir(zip_path):
        raise ValueError(f"The provided zip_path must be a directory. Received: {zip_path}")
    
    zip_file_name = "renamed_images.zip"
    zip_file_path = os.path.join(zip_path, zip_file_name)
    if os.path.exists(zip_file_path):
        os.remove(zip_file_path)

    with zipfile.ZipFile(zip_file_path, 'w') as zipf:
        added_files = set()  # To track the names of files added to the zip
        
        for file in renamed_files:
            base_name = os.path.basename(file)
            
            # Handle duplicate filenames by appending a number to the filename
            duplicate_count = 1
            new_name = base_name
            
            # Ensure the filename is unique inside the zip
            while new_name in added_files:
                file_name, file_extension = os.path.splitext(base_name)
                new_name = f"{file_name}_{duplicate_count}{file_extension}"
                duplicate_count += 1

            # Add the file to the zip with the unique name
            zipf.write(file, new_name)
            added_files.add(new_name)
    
    return zip_file_path


def clear_directory(directory):
    if os.path.exists(directory):
        shutil.rmtree(directory)
    os.makedirs(directory, exist_ok=True)