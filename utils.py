import os
import time
import shutil
import zipfile
from dotenv import load_dotenv
import google.generativeai as genai

load_dotenv()
genai.configure(api_key=os.environ['GEMINI_API_KEY'])


SAFE = [
        {
            "category": "HARM_CATEGORY_DANGEROUS",
            "threshold": "BLOCK_NONE",
        },
        {
            "category": "HARM_CATEGORY_HARASSMENT",
            "threshold": "BLOCK_NONE",
        },
        {
            "category": "HARM_CATEGORY_HATE_SPEECH",
            "threshold": "BLOCK_NONE",
        },
        {
            "category": "HARM_CATEGORY_SEXUALLY_EXPLICIT",
            "threshold": "BLOCK_NONE",
        },
        {
            "category": "HARM_CATEGORY_DANGEROUS_CONTENT",
            "threshold": "BLOCK_NONE",
        },
    ]    

def generate_new_name_from_text(original_name: str) -> str:
    """Generates a new name for a given file name using OpenAI.

    Args:
        original_name (str): The old name of the file.

    Returns:
        str: The new name of the file.
    """
    
    example = """Example 1: Original name: 'pikaso_texttoimage_Big-Parade-Float-With-Thanksgiving-Feasts-And-Perf' -> New name: 'Big Parade Float With Thanksgiving Feasts And Performance'
                 Example 2: Original name: 'pikaso_texttoimage_Big-Parade-Float-With-Thanksgiving-Feasts-And-Perf' -> New name: 'Big Parade Float With Thanksgiving Feasts'
                 Example 3: Original name: 'pikaso_edit_A-Cartoon-Dragon-Playing-The-Piano-In-A-Beautiful-' -> New name: 'A Cartoon Dragon Playing The Piano In A Beautifully'"""
   
    prompt = f""" You are provided with an original name of a file. {original_name} Your task is to generate a new name for the file, using the original name. 
    
    Original Name Explanation:
        1) The name is a description of the file, but it is not formatted correctly
        2) It starts with some kind of label which indicates it was generated by a text to image model. 
        3) The image name is often not complete and ends abrubtly.
    
    Instructions:
        1) Make sure to use the original name to understand what the file is about.
        2) Remove the tag that indicates it was generated by text to image,
        3) Make sure the new name is complete and descriptive. Rephrase it if needed to explain the image better.
        4) It should not have any dashes or underscores or special characters, and should be in title case and have alphabetical characters only.
        5) It should make sense and not sound incomplete. If you cannot complete the last word of the name, then come up with a name without using it.
        6) It should be grammatically correct.
        
    
    Use these examples for reference:
        {example} 
    
    Output:
        Your output should just be the new name. 
    """
    
    while True:
        try:
            model = genai.GenerativeModel("gemini-1.5-flash")        
            
            response = model.generate_content(
                prompt,
                safety_settings=SAFE
            )
            new_name = response.text.strip()
            break
        except Exception as e:
            print(f"Error generating new name: {e}")
            print("Sleeping for 5 seconds")
            time.sleep(5)
    
    return new_name


def generate_new_name_from_image(file_path: str) -> str:
    
    myfile = genai.upload_file(file_path)
    
    prompt = """You are provided with an image. Your task is to generate a new name for the image.
    
    Instructions:
    
        1) Make sure to look at the image and understand what it is about.
        2) The new name should be descriptive and should explain the image well.
        3) It should be in title case.
        It should not have any dashes or underscores or special characters, and should be in title case and have alphabetical characters only.
        5) It should be grammatically correct.

    Output:
        Your output should just be the new name.
    
    """
    while True:
        try:
            model = genai.GenerativeModel("gemini-1.5-flash")
            result = model.generate_content(
                [myfile, "\n\n", prompt],
                safety_settings=SAFE
            )
            
            new_name = result.text
            break;
        
        except Exception as e:
            print(f"Error generating new name: {e}")
            print("Sleeping for 5 seconds")
            time.sleep(5)
        
    return new_name
 

def zip_up(renamed_files: list, zip_path: str) -> str:
    """Zips up the selected files into a zip file, handling duplicates.

    Args:
        renamed_files (list): The list of file locations that need to be zipped up.
        zip_path (str): The path where the zip file should be saved. It is a directory path.

    Returns:
        str: The path of the zip file.
    """
    
    if not os.path.isdir(zip_path):
        raise ValueError(f"The provided zip_path must be a directory. Received: {zip_path}")
    
    zip_file_name = "renamed_images.zip"
    zip_file_path = os.path.join(zip_path, zip_file_name)
    if os.path.exists(zip_file_path):
        os.remove(zip_file_path)

    with zipfile.ZipFile(zip_file_path, 'w') as zipf:
        added_files = set()  # To track the names of files added to the zip
        
        for file in renamed_files:
            base_name = os.path.basename(file)
            
            # Handle duplicate filenames by appending a number to the filename
            duplicate_count = 1
            new_name = base_name
            
            # Ensure the filename is unique inside the zip
            while new_name in added_files:
                file_name, file_extension = os.path.splitext(base_name)
                new_name = f"{file_name}_{duplicate_count}{file_extension}"
                duplicate_count += 1

            # Add the file to the zip with the unique name
            zipf.write(file, new_name)
            added_files.add(new_name)
    
    return zip_file_path


def clear_directory(directory):
    if os.path.exists(directory):
        shutil.rmtree(directory)
    os.makedirs(directory, exist_ok=True)